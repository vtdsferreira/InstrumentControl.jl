```@meta
CurrentModule = InstrumentControl.AWGM320XA
DocTestSetup = quote
    using InstrumentControl
end
```


# Keysight M320XA AWGs

This module contains the many methods and types necessary to control and configure
the Keysight M3202A/M3201A AWGs. In essence, it wraps the [KeysightInstruments.jl](https://github.com/PainterQubits/KeysightInstruments.jl) package,
which in itself is a bare-bones wrapper to the native C library which controls
the Keysight instruments, in a way which affords compatibility with the rest of the InstrumentControl
package, as well as consistency between the control code of this instrument and other
instruments represented in this package.

## Usage/Configuration

###Instrument Overview

Each M320XA AWG card has several channels; each channel has it's own
*Function Generator* as well as it's own *Arbitary Waveform Generator*. The
function generator outputs sinusoids, triangular waves, and square waves. The user
can select the output of the channel to either come from the arbitrary waveform generator,
or from the function generator.

Moreover, the arbitrary waveform generator can be used to *modulate* the function
generator output: it can be used for amplitude modulation, phase modulation,
frequency modulation, or DC offset modulation

When used for amplitude modulation, the output signal is given by:
`Output(t) = (A + G*AWG(t))* cos(ωt + ϕ) + DC`

When used for phase modulation, the output signal is given by:
`Output(t) = A*cos(ωt + ϕ + G*AWG(t)) + DC`

When used for frequency modulation, the output signal is given by:
`Output(t) = A*cos((ω+G*AWG(t))* t + ϕ) + DC`

When used for DC offset modulation, the output signal is given by:
`Output(t) = A*cos(ωt + ϕ) + DC + G*AWG(t)`  

When using the AWG for direct output (not modulation):
`Output(t) = A*AWG(t) + DC`

- A is the channel amplitude configured by the user
- AWG(t) is the *normalized* waveform which is loaded and queued by the user and generated by the AWG
- f = ω/2π is the channel's function generator's frequency set by the user
- ϕ is the channel's function generator's relative phase configured by the user
- G is the "amplitude" of the AWG signal, which is configured by the user
- DC is the channel's DC offset, configured by the user.

Waveforms are loaded as *normalized* arrays (i.e., from -1 to 1) to the onboard RAM of the AWG;
when they are loaded the user specifies an number ID which servers as the handle to
the waveform from then on. The loaded waveforms are then queued onto particular
channels with the following parameters:
- Trigger mode (i.e.: Trigger from PXI or Software or Automatically)
- Delay from trigger to output
- Number of repetitions
- Prescaler

Then, after queueing the waveforms, we "start" the AWG (with our `awg_start` function),
which then starts outputting waveforms upon acquisition of triggers.

Moreover, each AWG card has it's own internal 100MHz clock which is phase-locked to the
chassis clock: any actions taken by the AWG occur on a clock tick (so in intervals
of 10ns), and different AWG/Digitizer cards are synchronized through the chassis clock.
Each card also has an extra port called the TRG port, on which triggers can be received or generated.

###Usage

All instrument control and configuration happens through the following
`Instrument` subtype:

```@docs
    InsAWGM320XA
```
For example, calling `InsAWGM320XA(3,1,num_channels = 4)` will open the AWG card on slot 3
on the PXI chassis indexed by 1 (internal Keysight software does the chassis "indexing");
`num_channels` corresponds to the number of channels in the AWG card. The second input,
which sets the value for the `chassis` field in the `InsAWGM320XA` object, is an optional
argument with default value `1` (for the case when only one chassis is connected to
the computer), while the `num_channels` input is a keyword argument whose default
value is `4` --> Hence, `InsAWGM320XA(3)` would make an instance of the same object.

Moreover, once waveforms are loaded and queued, each channel's AWG can be started
and checked to see if it's running with the following methods

```@docs
    awg_start
    awg_is_running
```

###Configuration

Configuration/Inspection of settings happens through setindex!/getindex methods, as
described in [Overview](https://painterqubits.github.io/InstrumentControl.jl/latest/ins_meas/)

These are the following properties which can be configured, each of which has it's
own `InstrumentProperty` subtype:

```@docs    
    OutputMode
    DCOffset
    FGFrequency
    FGPhase
    TrigSource
    TrigBehavior
    TrigSync
    Queue
    QueueCycleMode
    QueueSyncMode
    AmpModMode
    AngModMode
    AmpModGain
    AngModGain
```

## Waveforms

###Basics

In this module's implementation, we allow for handling of waveforms through the
following type:

```@docs
    Waveform
```
When a waveform is loaded into the RAM, the corresponding `Waveform` object is
stored in the `waveforms` field of the `InsAWGM320XA` object, indexed by the
ID specified when loading the waveform. When a waveform is queued in a particular
channel, it's ID is added to a list of the queued waveforms which can be accessed
by a `getindex` with `Queue` as the "index". This object conveniently stores the
waveform array values, a name (meant to be more descriptive than an integer), and
queue properties once a waveform is queued.

Natively, you load waveforms into the AWG as arrays through Keysight's native
C functions, where you specify an "id" which is the defacto handle for handling
waveforms for all subsequent queueing. However, once you load a waveform you can't
query the instrument to see it, and an id is not exactly a descriptive handle; moreover,
once you queue a waveform you can't query the instrument for what settings the waveform
was queued with (trigger_mode, delay, etc). We get around these nuisances by making
all loading and queueing of waveforms be tied to instantiating and manipulating these
`Waveform` objects. However, waveform manipulation can also be done through the
waveform ID's if so desired by the user.

### Usage

Once you have a `Waveform` object, or an array of values to load onto the AWG's RAM
as a waveform, these are the methods to load and queue waveforms, as well as to
empty the queues, empty the RAM, etc:

```@docs
    load_waveform
    queue_waveform
    waveforms_flush
    memory_size
```
